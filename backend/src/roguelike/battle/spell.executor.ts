/**
 * Spell Executor for Roguelike Mode
 *
 * Handles spell execution during battle based on HP thresholds.
 * Spells are triggered automatically when team HP drops below configured thresholds.
 *
 * @module roguelike/battle/spell-executor
 */

import { BattleEvent } from '../../types/game.types';
import { BattleUnit } from '../../types/game.types';
import {
  Spell,
  SpellExecution,
  SpellTiming,
} from '../types/leader.types';
import { getSpell, shouldTriggerSpell, UnitHpState } from '../data/leaders.data';

/**
 * Spell execution configuration for a battle.
 */
export interface SpellConfig {
  /** Player's spell executions */
  playerSpells: SpellExecution[];
  /** Enemy's spell executions */
  enemySpells: SpellExecution[];
}

/**
 * Result of checking and executing spells.
 */
export interface SpellExecutionResult {
  /** Events generated by spell execution */
  events: BattleEvent[];
  /** Updated player spell states */
  playerSpells: SpellExecution[];
  /** Updated enemy spell states */
  enemySpells: SpellExecution[];
  /** Units after spell effects applied */
  units: BattleUnit[];
}

/**
 * Creates default spell config (no spells).
 *
 * @returns Empty spell configuration
 * @example
 * const config = createEmptySpellConfig();
 */
export function createEmptySpellConfig(): SpellConfig {
  return {
    playerSpells: [],
    enemySpells: [],
  };
}

/**
 * Converts units to HP state for spell trigger checking.
 *
 * @param units - Battle units to convert
 * @param team - Team to filter by
 * @returns Array of unit HP states
 */
function getTeamHpStates(units: BattleUnit[], team: 'player' | 'bot'): UnitHpState[] {
  return units
    .filter((u) => u.team === team && u.alive)
    .map((u) => ({
      currentHp: u.currentHp,
      maxHp: u.maxHp,
    }));
}


/**
 * Finds the target unit for a spell based on target type.
 *
 * @param spell - Spell to find target for
 * @param units - All battle units
 * @param casterTeam - Team of the spell caster
 * @returns Target unit or null if no valid target
 */
function findSpellTarget(
  spell: Spell,
  units: BattleUnit[],
  casterTeam: 'player' | 'bot',
): BattleUnit | null {
  const allies = units.filter((u) => u.team === casterTeam && u.alive);
  const enemies = units.filter((u) => u.team !== casterTeam && u.alive);

  switch (spell.targetType) {
    case 'ally_lowest_hp':
      return allies.reduce<BattleUnit | null>((lowest, unit) => {
        if (!lowest) return unit;
        return unit.currentHp < lowest.currentHp ? unit : lowest;
      }, null);

    case 'enemy_highest_hp':
      return enemies.reduce<BattleUnit | null>((highest, unit) => {
        if (!highest) return unit;
        return unit.currentHp > highest.currentHp ? unit : highest;
      }, null);

    case 'all_allies':
    case 'all_enemies':
    case 'summon':
      // These don't need a single target
      return null;

    default:
      return null;
  }
}

/**
 * Executes a heal spell effect.
 *
 * @param spell - Spell being executed
 * @param units - All battle units
 * @param casterTeam - Team of the spell caster
 * @param round - Current battle round
 * @returns Events and updated units
 */
function executeHealSpell(
  spell: Spell,
  units: BattleUnit[],
  casterTeam: 'player' | 'bot',
  round: number,
): { events: BattleEvent[]; units: BattleUnit[] } {
  const events: BattleEvent[] = [];
  let updatedUnits = [...units];

  if (spell.targetType === 'ally_lowest_hp') {
    const target = findSpellTarget(spell, units, casterTeam);
    if (target) {
      const healAmount = Math.min(spell.effectValue, target.maxHp - target.currentHp);
      
      updatedUnits = updatedUnits.map((u) => {
        if (u.instanceId === target.instanceId) {
          return { ...u, currentHp: u.currentHp + healAmount };
        }
        return u;
      });

      events.push({
        round,
        type: 'heal',
        actorId: `${casterTeam}_leader`,
        targetId: target.instanceId,
        healing: healAmount,
        metadata: {
          spellId: spell.id,
          spellName: spell.name,
          message: `${spell.name} heals ${target.instanceId} for ${healAmount} HP`,
        },
      });
    }
  } else if (spell.targetType === 'all_allies') {
    const allies = units.filter((u) => u.team === casterTeam && u.alive);
    
    for (const ally of allies) {
      const healAmount = Math.min(spell.effectValue, ally.maxHp - ally.currentHp);
      
      updatedUnits = updatedUnits.map((u) => {
        if (u.instanceId === ally.instanceId) {
          return { ...u, currentHp: u.currentHp + healAmount };
        }
        return u;
      });

      if (healAmount > 0) {
        events.push({
          round,
          type: 'heal',
          actorId: `${casterTeam}_leader`,
          targetId: ally.instanceId,
          healing: healAmount,
          metadata: {
            spellId: spell.id,
            spellName: spell.name,
          },
        });
      }
    }
  }

  return { events, units: updatedUnits };
}

/**
 * Executes a damage spell effect.
 *
 * @param spell - Spell being executed
 * @param units - All battle units
 * @param casterTeam - Team of the spell caster
 * @param round - Current battle round
 * @returns Events and updated units
 */
function executeDamageSpell(
  spell: Spell,
  units: BattleUnit[],
  casterTeam: 'player' | 'bot',
  round: number,
): { events: BattleEvent[]; units: BattleUnit[] } {
  const events: BattleEvent[] = [];
  let updatedUnits = [...units];
  const enemyTeam = casterTeam === 'player' ? 'bot' : 'player';

  if (spell.targetType === 'enemy_highest_hp') {
    const target = findSpellTarget(spell, units, casterTeam);
    if (target) {
      const damage = spell.effectValue;
      const newHp = Math.max(0, target.currentHp - damage);
      const isDead = newHp <= 0;

      updatedUnits = updatedUnits.map((u) => {
        if (u.instanceId === target.instanceId) {
          return { ...u, currentHp: newHp, alive: !isDead };
        }
        return u;
      });

      events.push({
        round,
        type: 'damage',
        actorId: `${casterTeam}_leader`,
        targetId: target.instanceId,
        damage,
        metadata: {
          spellId: spell.id,
          spellName: spell.name,
          damageType: 'magic',
          message: `${spell.name} deals ${damage} damage to ${target.instanceId}`,
        },
      });

      if (isDead) {
        events.push({
          round,
          type: 'death',
          actorId: target.instanceId,
          metadata: {
            killedBy: `${casterTeam}_leader`,
            spellId: spell.id,
          },
        });
      }
    }
  } else if (spell.targetType === 'all_enemies') {
    const enemies = units.filter((u) => u.team === enemyTeam && u.alive);
    
    for (const enemy of enemies) {
      const damage = spell.effectValue;
      const newHp = Math.max(0, enemy.currentHp - damage);
      const isDead = newHp <= 0;

      updatedUnits = updatedUnits.map((u) => {
        if (u.instanceId === enemy.instanceId) {
          return { ...u, currentHp: newHp, alive: !isDead };
        }
        return u;
      });

      events.push({
        round,
        type: 'damage',
        actorId: `${casterTeam}_leader`,
        targetId: enemy.instanceId,
        damage,
        metadata: {
          spellId: spell.id,
          spellName: spell.name,
          damageType: 'magic',
        },
      });

      if (isDead) {
        events.push({
          round,
          type: 'death',
          actorId: enemy.instanceId,
          metadata: {
            killedBy: `${casterTeam}_leader`,
            spellId: spell.id,
          },
        });
      }
    }
  }

  return { events, units: updatedUnits };
}


/**
 * Executes a buff spell effect.
 *
 * @param spell - Spell being executed
 * @param units - All battle units
 * @param casterTeam - Team of the spell caster
 * @param round - Current battle round
 * @returns Events and updated units
 */
function executeBuffSpell(
  spell: Spell,
  units: BattleUnit[],
  casterTeam: 'player' | 'bot',
  round: number,
): { events: BattleEvent[]; units: BattleUnit[] } {
  const events: BattleEvent[] = [];
  // Note: Buff application would require status effect system integration
  // For now, we just generate the event
  
  if (spell.targetType === 'all_allies') {
    const allies = units.filter((u) => u.team === casterTeam && u.alive);
    
    events.push({
      round,
      type: 'buff',
      actorId: `${casterTeam}_leader`,
      metadata: {
        spellId: spell.id,
        spellName: spell.name,
        buffType: 'atk_boost',
        buffValue: spell.effectValue,
        duration: spell.duration ?? 1,
        affectedUnits: allies.map((u) => u.instanceId),
        message: `${spell.name} buffs ${allies.length} allies with +${Math.round(spell.effectValue * 100)}% ATK`,
      },
    });
  }

  return { events, units };
}

/**
 * Executes a summon spell effect.
 *
 * @param spell - Spell being executed
 * @param units - All battle units
 * @param casterTeam - Team of the spell caster
 * @param round - Current battle round
 * @returns Events and updated units
 */
function executeSummonSpell(
  spell: Spell,
  units: BattleUnit[],
  casterTeam: 'player' | 'bot',
  round: number,
): { events: BattleEvent[]; units: BattleUnit[] } {
  const events: BattleEvent[] = [];
  // Note: Summon would require finding empty positions and creating units
  // For now, we just generate the event using 'ability' type
  
  events.push({
    round,
    type: 'ability',
    actorId: `${casterTeam}_leader`,
    abilityId: spell.id,
    metadata: {
      spellId: spell.id,
      spellName: spell.name,
      summonCount: spell.effectValue,
      effectType: 'summon',
      message: `${spell.name} summons ${spell.effectValue} units`,
    },
  });

  return { events, units };
}

/**
 * Executes a single spell effect.
 *
 * @param spell - Spell to execute
 * @param units - All battle units
 * @param casterTeam - Team of the spell caster
 * @param round - Current battle round
 * @returns Events and updated units
 */
function executeSpellEffect(
  spell: Spell,
  units: BattleUnit[],
  casterTeam: 'player' | 'bot',
  round: number,
): { events: BattleEvent[]; units: BattleUnit[] } {
  // Add spell cast event using 'ability' type
  const castEvent: BattleEvent = {
    round,
    type: 'ability',
    actorId: `${casterTeam}_leader`,
    abilityId: spell.id,
    metadata: {
      spellId: spell.id,
      spellName: spell.name,
      effectType: spell.effectType,
      targetType: spell.targetType,
      isSpell: true,
      message: `${casterTeam === 'player' ? 'Player' : 'Enemy'} leader casts ${spell.name}`,
    },
  };

  let result: { events: BattleEvent[]; units: BattleUnit[] };

  switch (spell.effectType) {
    case 'heal':
      result = executeHealSpell(spell, units, casterTeam, round);
      break;
    case 'damage':
      result = executeDamageSpell(spell, units, casterTeam, round);
      break;
    case 'buff':
      result = executeBuffSpell(spell, units, casterTeam, round);
      break;
    case 'summon':
      result = executeSummonSpell(spell, units, casterTeam, round);
      break;
    default:
      result = { events: [], units };
  }

  return {
    events: [castEvent, ...result.events],
    units: result.units,
  };
}

/**
 * Checks and executes spells for a team based on HP thresholds.
 *
 * @param spells - Team's spell executions
 * @param units - All battle units
 * @param team - Team to check spells for
 * @param round - Current battle round
 * @returns Updated spells, events, and units
 */
function checkAndExecuteTeamSpells(
  spells: SpellExecution[],
  units: BattleUnit[],
  team: 'player' | 'bot',
  round: number,
): { spells: SpellExecution[]; events: BattleEvent[]; units: BattleUnit[] } {
  const events: BattleEvent[] = [];
  let currentUnits = units;
  const updatedSpells = [...spells];

  const teamHpStates = getTeamHpStates(currentUnits, team);

  for (let i = 0; i < updatedSpells.length; i++) {
    const spellExec = updatedSpells[i];
    if (!spellExec || spellExec.triggered) continue;

    if (shouldTriggerSpell(spellExec, teamHpStates)) {
      const spell = getSpell(spellExec.spellId);
      if (spell) {
        const result = executeSpellEffect(spell, currentUnits, team, round);
        events.push(...result.events);
        currentUnits = result.units;
        
        // Mark spell as triggered
        updatedSpells[i] = { ...spellExec, triggered: true };
      }
    }
  }

  return { spells: updatedSpells, events, units: currentUnits };
}

/**
 * Checks and executes all pending spells for both teams.
 *
 * Called at the start of each round to check HP thresholds
 * and trigger any spells that should activate.
 *
 * @param config - Current spell configuration
 * @param units - All battle units
 * @param round - Current battle round
 * @returns Updated spell config, events, and units
 *
 * @example
 * const result = checkAndExecuteSpells(spellConfig, battleUnits, currentRound);
 * allEvents.push(...result.events);
 * battleUnits = result.units;
 * spellConfig = { playerSpells: result.playerSpells, enemySpells: result.enemySpells };
 */
export function checkAndExecuteSpells(
  config: SpellConfig,
  units: BattleUnit[],
  round: number,
): SpellExecutionResult {
  let currentUnits = units;
  const allEvents: BattleEvent[] = [];

  // Check player spells
  const playerResult = checkAndExecuteTeamSpells(
    config.playerSpells,
    currentUnits,
    'player',
    round,
  );
  allEvents.push(...playerResult.events);
  currentUnits = playerResult.units;

  // Check enemy spells
  const enemyResult = checkAndExecuteTeamSpells(
    config.enemySpells,
    currentUnits,
    'bot',
    round,
  );
  allEvents.push(...enemyResult.events);
  currentUnits = enemyResult.units;

  return {
    events: allEvents,
    playerSpells: playerResult.spells,
    enemySpells: enemyResult.spells,
    units: currentUnits,
  };
}

/**
 * Creates spell executions from spell timing configurations.
 *
 * @param spellTimings - Array of spell ID and timing pairs
 * @returns Array of spell execution objects
 *
 * @example
 * const executions = createSpellExecutions([
 *   { spellId: 'holy_light', timing: 'mid' },
 *   { spellId: 'rally', timing: 'early' },
 * ]);
 */
export function createSpellExecutions(
  spellTimings: Array<{ spellId: string; timing: SpellTiming }>,
): SpellExecution[] {
  return spellTimings.map(({ spellId, timing }) => ({
    spellId,
    timing,
    triggered: false,
  }));
}
