/**
 * Ability Execution System for Fantasy Autobattler.
 * Handles ability validation, targeting, and effect application.
 * 
 * @fileoverview Pure functions for executing abilities during battle.
 * All functions are deterministic for consistent replay behavior.
 */

import { BattleUnit, Position, TeamType } from '../types/game.types';
import {
  AbilityEvent as CoreAbilityEvent,
  EffectResult,
} from '../core/types/event.types';
import {
  Ability,
  ActiveAbility,
  PassiveAbility,
  AbilityEffect,
  DamageEffect,
  HealEffect,
  BuffEffect,
  DebuffEffect,
  StunEffect,
  TauntEffect,
  isActiveAbility,
  isPassiveAbility,
} from '../types/ability.types';
import { BattleState } from './actions';
import { manhattanDistance } from './grid';
import { applyDamage, applyHealing } from './damage';
import { BATTLE_LIMITS } from '../config/game.constants';
import { seededRandom } from '../core/utils/random';

// Re-export EffectResult for backward compatibility
export type { EffectResult } from '../core/types/event.types';

// =============================================================================
// RESULT INTERFACES
// =============================================================================

/**
 * Event generated by ability execution.
 * Extends core AbilityEvent with game-specific fields.
 */
export interface AbilityEvent extends CoreAbilityEvent {
  // All fields inherited from CoreAbilityEvent
}

/**
 * Extended battle unit with ability state.
 */
export interface BattleUnitWithAbilities extends BattleUnit {
  /** Current ability cooldowns (abilityId -> remaining turns) */
  abilityCooldowns?: Record<string, number>;
  /** Active status effects */
  statusEffects?: StatusEffectInstance[];
  /** Whether unit is stunned */
  isStunned?: boolean;
  /** Whether unit has taunt active */
  hasTaunt?: boolean;
  /** Taunt remaining duration */
  tauntDuration?: number;
}

/**
 * Active status effect on a unit.
 */
export interface StatusEffectInstance {
  /** Effect ID */
  id: string;
  /** Source ability ID */
  sourceAbilityId: string;
  /** Source unit ID */
  sourceUnitId: string;
  /** Effect type */
  type: 'buff' | 'debuff' | 'stun' | 'taunt' | 'dot' | 'hot';
  /** Stat modified (for buff/debuff) */
  stat?: string;
  /** Modifier value */
  value?: number;
  /** Whether percentage-based */
  isPercentage?: boolean;
  /** Remaining duration */
  remainingDuration: number;
}

// =============================================================================
// ABILITY VALIDATION
// =============================================================================

/**
 * Check if a unit can use a specific ability.
 * Validates cooldown, stun status, and ability requirements.
 * 
 * @param unit - Unit attempting to use ability
 * @param ability - Ability to check
 * @param state - Current battle state
 * @returns True if ability can be used
 * @example
 * const canUse = canUseAbility(mage, fireballAbility, battleState);
 */
export function canUseAbility(
  unit: BattleUnitWithAbilities,
  ability: Ability,
  state: BattleState
): boolean {
  // Dead units cannot use abilities
  if (!unit.alive) {
    return false;
  }
  
  // Passive abilities are always "usable" (they trigger automatically)
  if (isPassiveAbility(ability)) {
    return true;
  }
  
  const activeAbility = ability as ActiveAbility;
  
  // Check if unit is stunned (unless ability is usable while stunned)
  if (unit.isStunned && !activeAbility.usableWhileStunned) {
    return false;
  }
  
  // Check cooldown
  const cooldowns = unit.abilityCooldowns ?? {};
  const currentCooldown = cooldowns[ability.id] ?? 0;
  if (currentCooldown > 0) {
    return false;
  }
  
  // Check if there are valid targets
  const validTargets = getValidTargets(unit, ability, state);
  if (validTargets.length === 0 && ability.targetType !== 'self' && ability.targetType !== 'area') {
    return false;
  }
  
  // For area abilities, we can always target any position within range
  // The actual target validation happens in executeAbility
  
  return true;
}

/**
 * Check if passive ability should trigger.
 * Evaluates trigger conditions based on battle context.
 * 
 * @param unit - Unit with passive ability
 * @param ability - Passive ability to check
 * @param triggerContext - Context of the trigger event
 * @returns True if passive should trigger
 * @example
 * const shouldTrigger = shouldPassiveTrigger(berserker, rageAbility, { type: 'on_low_hp', currentHpPercent: 40 });
 */
export function shouldPassiveTrigger(
  unit: BattleUnitWithAbilities,
  ability: PassiveAbility,
  triggerContext: {
    type: string;
    currentHpPercent?: number;
    attackerPosition?: Position;
    targetPosition?: Position;
  }
): boolean {
  if (!unit.alive) {
    return false;
  }
  
  // Check if trigger type matches
  if (ability.trigger !== triggerContext.type) {
    return false;
  }
  
  // Check trigger threshold for HP-based triggers
  if (ability.trigger === 'on_low_hp' && ability.triggerThreshold !== undefined) {
    const hpPercent = triggerContext.currentHpPercent ?? (unit.currentHp / unit.maxHp) * 100;
    if (hpPercent > ability.triggerThreshold) {
      return false;
    }
  }
  
  // Check internal cooldown
  const cooldowns = unit.abilityCooldowns ?? {};
  const currentCooldown = cooldowns[ability.id] ?? 0;
  if (currentCooldown > 0) {
    return false;
  }
  
  return true;
}

// =============================================================================
// TARGET SELECTION
// =============================================================================

/**
 * Get all valid targets for an ability.
 * Filters units based on ability targeting type and range.
 * 
 * @param unit - Unit using the ability
 * @param ability - Ability being used
 * @param state - Current battle state
 * @returns Array of valid target units
 * @example
 * const targets = getValidTargets(priest, healAbility, battleState);
 */
export function getValidTargets(
  unit: BattleUnitWithAbilities,
  ability: Ability,
  state: BattleState
): BattleUnit[] {
  const allUnits = state.units.filter(u => u.alive);
  const allies = allUnits.filter(u => u.team === unit.team);
  const enemies = allUnits.filter(u => u.team !== unit.team);
  
  switch (ability.targetType) {
    case 'self':
      return [unit];
      
    case 'ally':
      // Filter allies within range (excluding self for some abilities)
      return allies.filter(ally => {
        if (ability.range === 0) return true; // Unlimited range
        const distance = manhattanDistance(unit.position, ally.position);
        return distance <= ability.range;
      });
      
    case 'enemy':
      // Filter enemies within range
      return enemies.filter(enemy => {
        if (ability.range === -1) return true; // Unlimited range
        const distance = manhattanDistance(unit.position, enemy.position);
        return distance <= ability.range;
      });
      
    case 'area':
      // For area abilities, return enemies that could be hit
      return enemies.filter(enemy => {
        if (ability.range === -1) return true;
        const distance = manhattanDistance(unit.position, enemy.position);
        return distance <= ability.range;
      });
      
    case 'all_allies':
      return allies;
      
    case 'all_enemies':
      return enemies;
      
    case 'lowest_hp_ally': {
      if (allies.length === 0) return [];
      const lowestAlly = allies.reduce((lowest, current) => 
        (current.currentHp / current.maxHp) < (lowest.currentHp / lowest.maxHp) ? current : lowest
      );
      return [lowestAlly];
    }
      
    case 'lowest_hp_enemy': {
      if (enemies.length === 0) return [];
      const lowestEnemy = enemies.reduce((lowest, current) =>
        (current.currentHp / current.maxHp) < (lowest.currentHp / lowest.maxHp) ? current : lowest
      );
      return [lowestEnemy];
    }
      
    case 'random_ally': {
      if (allies.length === 0) return [];
      const firstAlly = allies[0];
      return firstAlly ? [firstAlly] : []; // Deterministic: always first ally
    }
      
    case 'random_enemy': {
      if (enemies.length === 0) return [];
      const firstEnemy = enemies[0];
      return firstEnemy ? [firstEnemy] : []; // Deterministic: always first enemy
    }
      
    default:
      return [];
  }
}

/**
 * Get units in area of effect.
 * Returns all units within areaSize of target position.
 * 
 * @param targetPosition - Center of AoE
 * @param areaSize - Radius of effect
 * @param units - All units to check
 * @param targetTeam - Team to target ('enemy' | 'ally' | 'all')
 * @param casterTeam - Team of the caster
 * @returns Units within AoE
 */
export function getUnitsInAoE(
  targetPosition: Position,
  areaSize: number,
  units: BattleUnit[],
  targetTeam: 'enemy' | 'ally' | 'all',
  casterTeam: TeamType
): BattleUnit[] {
  return units.filter(unit => {
    if (!unit.alive) return false;
    
    // Check team filter
    if (targetTeam === 'enemy' && unit.team === casterTeam) return false;
    if (targetTeam === 'ally' && unit.team !== casterTeam) return false;
    
    // Check distance
    const distance = manhattanDistance(targetPosition, unit.position);
    return distance <= areaSize;
  });
}

// =============================================================================
// EFFECT APPLICATION
// =============================================================================

/**
 * Apply a single effect to a target unit.
 * Handles all effect types: damage, heal, buff, debuff, stun, taunt.
 * 
 * @param effect - Effect to apply
 * @param target - Target unit
 * @param caster - Unit casting the ability
 * @param seed - Random seed for deterministic results
 * @returns Result of effect application
 * @example
 * const result = applyEffect(damageEffect, enemy, mage, 12345);
 */
export function applyEffect(
  effect: AbilityEffect,
  target: BattleUnitWithAbilities,
  caster: BattleUnitWithAbilities,
  seed: number = 0
): EffectResult {
  // Check effect chance
  if (effect.chance !== undefined && effect.chance < 100) {
    const roll = seededRandom(seed) * 100;
    if (roll >= effect.chance) {
      return {
        success: false,
        effectType: effect.type,
        targetId: target.instanceId,
        resisted: true,
      };
    }
  }
  
  switch (effect.type) {
    case 'damage':
      return applyDamageEffect(effect as DamageEffect, target, caster, seed);
      
    case 'heal':
      return applyHealEffect(effect as HealEffect, target, caster);
      
    case 'buff':
      return applyBuffEffect(effect as BuffEffect, target, caster);
      
    case 'debuff':
      return applyDebuffEffect(effect as DebuffEffect, target, caster);
      
    case 'stun':
      return applyStunEffect(effect as StunEffect, target, caster);
      
    case 'taunt':
      return applyTauntEffect(effect as TauntEffect, target, caster);
      
    default:
      return {
        success: false,
        effectType: effect.type,
        targetId: target.instanceId,
      };
  }
}

/**
 * Apply damage effect to target.
 */
function applyDamageEffect(
  effect: DamageEffect,
  target: BattleUnitWithAbilities,
  caster: BattleUnitWithAbilities,
  _seed: number
): EffectResult {
  // Calculate base damage
  let damage = effect.value;
  
  // Add attack scaling
  if (effect.attackScaling) {
    damage += Math.floor(caster.stats.atk * effect.attackScaling);
  }
  
  // Apply armor reduction for physical damage
  if (effect.damageType === 'physical') {
    damage = Math.max(BATTLE_LIMITS.MIN_DAMAGE, damage - target.stats.armor);
  }
  // Magical and true damage ignore armor
  
  // Apply damage
  const damageResult = applyDamage(target, damage);
  
  return {
    success: true,
    effectType: 'damage',
    targetId: target.instanceId,
    damage,
    killed: damageResult.killed,
    newHp: damageResult.newHp,
  };
}

/**
 * Apply heal effect to target.
 */
function applyHealEffect(
  effect: HealEffect,
  target: BattleUnitWithAbilities,
  caster: BattleUnitWithAbilities
): EffectResult {
  // Calculate heal amount
  let healing = effect.value;
  
  // Add attack scaling (for abilities that scale with caster's attack)
  if (effect.attackScaling) {
    healing += Math.floor(caster.stats.atk * effect.attackScaling);
  }
  
  // Apply healing
  const healResult = applyHealing(target, healing);
  
  return {
    success: true,
    effectType: 'heal',
    targetId: target.instanceId,
    healing: healing - healResult.overheal, // Actual healing done
    newHp: healResult.newHp,
  };
}

/**
 * Apply buff effect to target.
 */
function applyBuffEffect(
  effect: BuffEffect,
  target: BattleUnitWithAbilities,
  _caster: BattleUnitWithAbilities
): EffectResult {
  const modifierValue = effect.value ?? (effect.percentage ? effect.percentage * 100 : 0);
  
  return {
    success: true,
    effectType: 'buff',
    targetId: target.instanceId,
    statModified: effect.stat,
    modifierValue,
    duration: effect.duration,
  };
}

/**
 * Apply debuff effect to target.
 */
function applyDebuffEffect(
  effect: DebuffEffect,
  target: BattleUnitWithAbilities,
  _caster: BattleUnitWithAbilities
): EffectResult {
  const modifierValue = effect.value ?? (effect.percentage ? effect.percentage * 100 : 0);
  
  return {
    success: true,
    effectType: 'debuff',
    targetId: target.instanceId,
    statModified: effect.stat,
    modifierValue: -modifierValue, // Negative for debuffs
    duration: effect.duration,
  };
}

/**
 * Apply stun effect to target.
 */
function applyStunEffect(
  effect: StunEffect,
  target: BattleUnitWithAbilities,
  _caster: BattleUnitWithAbilities
): EffectResult {
  return {
    success: true,
    effectType: 'stun',
    targetId: target.instanceId,
    duration: effect.duration,
  };
}

/**
 * Apply taunt effect to caster (self-buff).
 */
function applyTauntEffect(
  effect: TauntEffect,
  target: BattleUnitWithAbilities,
  _caster: BattleUnitWithAbilities
): EffectResult {
  return {
    success: true,
    effectType: 'taunt',
    targetId: target.instanceId,
    duration: effect.duration,
  };
}


// =============================================================================
// ABILITY EXECUTION
// =============================================================================

/**
 * Execute an ability on a target or position.
 * Handles all ability types and generates appropriate events.
 * 
 * @param unit - Unit using the ability
 * @param ability - Ability being used
 * @param target - Target unit or position (for AoE)
 * @param state - Current battle state
 * @param seed - Random seed for deterministic results
 * @returns Array of ability events generated
 * @example
 * const events = executeAbility(mage, fireballAbility, targetPosition, battleState, 12345);
 */
export function executeAbility(
  unit: BattleUnitWithAbilities,
  ability: Ability,
  target: BattleUnit | Position,
  state: BattleState,
  seed: number
): AbilityEvent[] {
  const events: AbilityEvent[] = [];
  
  // Validate ability can be used
  if (!canUseAbility(unit, ability, state)) {
    return events;
  }
  
  // Determine targets based on ability type
  let targets: BattleUnit[] = [];
  let targetPosition: Position;
  
  if ('instanceId' in target) {
    // Target is a unit
    targetPosition = target.position;
    targets = [target];
  } else {
    // Target is a position (for AoE)
    targetPosition = target;
  }
  
  // Handle different target types
  if (ability.targetType === 'self') {
    targets = [unit];
  } else if (ability.targetType === 'all_allies') {
    targets = state.units.filter(u => u.alive && u.team === unit.team);
  } else if (ability.targetType === 'all_enemies') {
    targets = state.units.filter(u => u.alive && u.team !== unit.team);
  } else if (ability.targetType === 'area' && isActiveAbility(ability)) {
    const activeAbility = ability as ActiveAbility;
    const areaSize = activeAbility.areaSize ?? 1;
    targets = getUnitsInAoE(
      targetPosition,
      areaSize,
      state.units,
      'enemy',
      unit.team
    );
  } else if (ability.targetType === 'lowest_hp_ally') {
    const allies = state.units.filter(u => u.alive && u.team === unit.team);
    if (allies.length > 0) {
      targets = [allies.reduce((lowest, current) =>
        (current.currentHp / current.maxHp) < (lowest.currentHp / lowest.maxHp) ? current : lowest
      )];
    }
  } else if (ability.targetType === 'lowest_hp_enemy') {
    const enemies = state.units.filter(u => u.alive && u.team !== unit.team);
    if (enemies.length > 0) {
      targets = [enemies.reduce((lowest, current) =>
        (current.currentHp / current.maxHp) < (lowest.currentHp / lowest.maxHp) ? current : lowest
      )];
    }
  }
  
  if (targets.length === 0) {
    return events;
  }
  
  // Apply effects to all targets
  const effectResults: EffectResult[] = [];
  let totalDamage = 0;
  let totalHealing = 0;
  const killedUnits: string[] = [];
  
  let effectSeed = seed;
  
  for (const targetUnit of targets) {
    for (const effect of ability.effects) {
      const result = applyEffect(
        effect,
        targetUnit as BattleUnitWithAbilities,
        unit,
        effectSeed
      );
      effectResults.push(result);
      
      // Accumulate totals
      if (result.damage) {
        totalDamage += result.damage;
      }
      if (result.healing) {
        totalHealing += result.healing;
      }
      if (result.killed) {
        killedUnits.push(targetUnit.instanceId);
      }
      
      // Increment seed for next effect
      effectSeed = (effectSeed * 1103515245 + 12345) >>> 0;
    }
  }
  
  // Create ability event
  const firstTarget = targets[0];
  const singleTargetId = targets.length === 1 && firstTarget ? firstTarget.instanceId : null;
  const multiTargetIds = targets.length > 1 ? targets.map(t => t.instanceId) : null;
  
  const abilityEvent: AbilityEvent = {
    round: state.currentRound,
    type: 'ability',
    actorId: unit.instanceId,
    ...(singleTargetId !== null && { targetId: singleTargetId }),
    ...(multiTargetIds !== null && { targetIds: multiTargetIds }),
    abilityId: ability.id,
    effectResults,
  };
  
  if (totalDamage > 0) {
    abilityEvent.totalDamage = totalDamage;
  }
  if (totalHealing > 0) {
    abilityEvent.totalHealing = totalHealing;
  }
  if (killedUnits.length > 0) {
    abilityEvent.killedUnits = killedUnits;
  }
  
  events.push(abilityEvent);
  
  return events;
}

/**
 * Execute a passive ability trigger.
 * Called when trigger conditions are met during battle.
 * 
 * @param unit - Unit with passive ability
 * @param ability - Passive ability to trigger
 * @param triggerContext - Context of the trigger
 * @param state - Current battle state
 * @param seed - Random seed
 * @returns Array of events generated
 */
export function executePassiveTrigger(
  unit: BattleUnitWithAbilities,
  ability: PassiveAbility,
  triggerContext: {
    type: string;
    target?: BattleUnit;
    attacker?: BattleUnit;
  },
  state: BattleState,
  seed: number
): AbilityEvent[] {
  // Determine target based on passive type
  let target: BattleUnit | Position;
  
  switch (ability.targetType) {
    case 'self':
      target = unit;
      break;
    case 'enemy':
      target = triggerContext.target ?? triggerContext.attacker ?? unit;
      break;
    default:
      target = unit;
  }
  
  return executeAbility(unit, ability, target, state, seed);
}

// =============================================================================
// STATE UPDATE FUNCTIONS
// =============================================================================

/**
 * Apply ability events to battle state.
 * Updates unit HP, status effects, and cooldowns.
 * 
 * @param state - Current battle state
 * @param events - Ability events to apply
 * @param ability - Ability that was used
 * @param casterId - ID of the unit that used the ability
 * @returns Updated battle state
 */
export function applyAbilityEvents(
  state: BattleState,
  events: AbilityEvent[],
  ability: Ability,
  casterId: string
): BattleState {
  const updatedUnits = new Map<string, BattleUnitWithAbilities>();
  
  // Initialize with current units
  state.units.forEach(unit => {
    updatedUnits.set(unit.instanceId, { ...unit } as BattleUnitWithAbilities);
  });
  
  // Process each event
  for (const event of events) {
    for (const result of event.effectResults) {
      const target = updatedUnits.get(result.targetId);
      if (!target) continue;
      
      // Apply HP changes
      if (result.newHp !== undefined) {
        target.currentHp = result.newHp;
        target.alive = result.newHp > 0;
      }
      
      // Apply status effects
      if (result.effectType === 'stun' && result.duration) {
        target.isStunned = true;
        target.statusEffects = target.statusEffects ?? [];
        target.statusEffects.push({
          id: `stun_${Date.now()}`,
          sourceAbilityId: ability.id,
          sourceUnitId: casterId,
          type: 'stun',
          remainingDuration: result.duration,
        });
      }
      
      if (result.effectType === 'taunt' && result.duration) {
        target.hasTaunt = true;
        target.tauntDuration = result.duration;
      }
      
      if ((result.effectType === 'buff' || result.effectType === 'debuff') && result.duration && result.statModified) {
        target.statusEffects = target.statusEffects ?? [];
        const statusEffect: StatusEffectInstance = {
          id: `${result.effectType}_${result.statModified}_${Date.now()}`,
          sourceAbilityId: ability.id,
          sourceUnitId: casterId,
          type: result.effectType,
          stat: result.statModified,
          isPercentage: true,
          remainingDuration: result.duration,
        };
        // Only add value if it's defined
        if (result.modifierValue !== undefined) {
          statusEffect.value = result.modifierValue;
        }
        target.statusEffects.push(statusEffect);
      }
      
      updatedUnits.set(result.targetId, target);
    }
  }
  
  // Set cooldown for active abilities
  if (isActiveAbility(ability)) {
    const caster = updatedUnits.get(casterId);
    if (caster) {
      caster.abilityCooldowns = caster.abilityCooldowns ?? {};
      caster.abilityCooldowns[ability.id] = (ability as ActiveAbility).cooldown;
      updatedUnits.set(casterId, caster);
    }
  }
  
  // Rebuild occupied positions
  const occupiedPositions = new Set<string>();
  updatedUnits.forEach(unit => {
    if (unit.alive) {
      occupiedPositions.add(`${unit.position.x},${unit.position.y}`);
    }
  });
  
  return {
    ...state,
    units: Array.from(updatedUnits.values()),
    occupiedPositions,
  };
}

/**
 * Tick status effects at end of turn.
 * Decrements durations and removes expired effects.
 * 
 * @param unit - Unit to tick effects for
 * @returns Updated unit with ticked effects
 */
export function tickStatusEffects(unit: BattleUnitWithAbilities): BattleUnitWithAbilities {
  if (!unit.statusEffects || unit.statusEffects.length === 0) {
    return unit;
  }
  
  const updatedEffects: StatusEffectInstance[] = [];
  let isStunned = false;
  let hasTaunt = false;
  let tauntDuration = 0;
  
  for (const effect of unit.statusEffects) {
    const newDuration = effect.remainingDuration - 1;
    
    if (newDuration > 0) {
      updatedEffects.push({
        ...effect,
        remainingDuration: newDuration,
      });
      
      if (effect.type === 'stun') {
        isStunned = true;
      }
      if (effect.type === 'taunt') {
        hasTaunt = true;
        tauntDuration = newDuration;
      }
    }
  }
  
  const result: BattleUnitWithAbilities = {
    ...unit,
    statusEffects: updatedEffects,
    isStunned,
    hasTaunt,
  };
  
  // Only set tauntDuration if hasTaunt is true
  if (hasTaunt) {
    result.tauntDuration = tauntDuration;
  }
  
  return result;
}

/**
 * Tick ability cooldowns at end of turn.
 * Decrements all cooldowns by 1.
 * 
 * @param unit - Unit to tick cooldowns for
 * @returns Updated unit with ticked cooldowns
 */
export function tickAbilityCooldowns(unit: BattleUnitWithAbilities): BattleUnitWithAbilities {
  if (!unit.abilityCooldowns) {
    return unit;
  }
  
  const updatedCooldowns: Record<string, number> = {};
  
  for (const [abilityId, cooldown] of Object.entries(unit.abilityCooldowns)) {
    const newCooldown = Math.max(0, cooldown - 1);
    if (newCooldown > 0) {
      updatedCooldowns[abilityId] = newCooldown;
    }
  }
  
  return {
    ...unit,
    abilityCooldowns: updatedCooldowns,
  };
}

// =============================================================================
// STAT MODIFICATION
// =============================================================================

/**
 * Calculate effective stat value with all modifiers applied.
 * Applies buffs and debuffs to base stat.
 * 
 * @param unit - Unit to calculate stat for
 * @param statName - Name of stat to calculate
 * @param baseValue - Base stat value
 * @returns Effective stat value after modifiers
 */
export function calculateEffectiveStat(
  unit: BattleUnitWithAbilities,
  statName: string,
  baseValue: number
): number {
  if (!unit.statusEffects || unit.statusEffects.length === 0) {
    return baseValue;
  }
  
  let flatModifier = 0;
  let percentModifier = 0;
  
  for (const effect of unit.statusEffects) {
    if (effect.stat !== statName) continue;
    
    if (effect.isPercentage && effect.value) {
      percentModifier += effect.value / 100;
    } else if (effect.value) {
      flatModifier += effect.value;
    }
  }
  
  // Apply percentage first, then flat
  const afterPercent = baseValue * (1 + percentModifier);
  const finalValue = afterPercent + flatModifier;
  
  // Ensure non-negative
  return Math.max(0, Math.floor(finalValue));
}

/**
 * Get unit's effective stats with all modifiers.
 * 
 * @param unit - Unit to get effective stats for
 * @returns Object with all effective stat values
 */
export function getEffectiveStats(unit: BattleUnitWithAbilities): {
  atk: number;
  armor: number;
  speed: number;
  initiative: number;
  dodge: number;
} {
  return {
    atk: calculateEffectiveStat(unit, 'attack', unit.stats.atk),
    armor: calculateEffectiveStat(unit, 'armor', unit.stats.armor),
    speed: calculateEffectiveStat(unit, 'speed', unit.stats.speed),
    initiative: calculateEffectiveStat(unit, 'initiative', unit.stats.initiative),
    dodge: calculateEffectiveStat(unit, 'dodge', unit.stats.dodge),
  };
}

// =============================================================================
// AI ABILITY SELECTION
// =============================================================================

/**
 * Select best ability for AI unit to use.
 * Evaluates available abilities and targets to choose optimal action.
 * 
 * @param unit - AI unit selecting ability
 * @param abilities - Available abilities
 * @param state - Current battle state
 * @returns Selected ability and target, or null if no ability should be used
 */
export function selectBestAbility(
  unit: BattleUnitWithAbilities,
  abilities: Ability[],
  state: BattleState
): { ability: Ability; target: BattleUnit | Position } | null {
  const usableAbilities = abilities.filter(ability => 
    isActiveAbility(ability) && canUseAbility(unit, ability, state)
  );
  
  if (usableAbilities.length === 0) {
    return null;
  }
  
  // Simple priority: healing > damage > buffs
  const allies = state.units.filter(u => u.alive && u.team === unit.team);
  const enemies = state.units.filter(u => u.alive && u.team !== unit.team);
  
  // Check for healing abilities if allies are hurt
  const hurtAllies = allies.filter(a => a.currentHp < a.maxHp * 0.5);
  if (hurtAllies.length > 0) {
    const healAbility = usableAbilities.find(a => 
      a.effects.some(e => e.type === 'heal')
    );
    if (healAbility) {
      const lowestAlly = hurtAllies.reduce((lowest, current) =>
        current.currentHp < lowest.currentHp ? current : lowest
      );
      return { ability: healAbility, target: lowestAlly };
    }
  }
  
  // Check for damage abilities
  if (enemies.length > 0) {
    const damageAbility = usableAbilities.find(a =>
      a.effects.some(e => e.type === 'damage')
    );
    if (damageAbility) {
      // Target lowest HP enemy for finishing
      const lowestEnemy = enemies.reduce((lowest, current) =>
        current.currentHp < lowest.currentHp ? current : lowest
      );
      return { ability: damageAbility, target: lowestEnemy };
    }
  }
  
  // Check for buff abilities
  const buffAbility = usableAbilities.find(a =>
    a.effects.some(e => e.type === 'buff')
  );
  if (buffAbility) {
    return { ability: buffAbility, target: unit };
  }
  
  // Check for CC abilities
  if (enemies.length > 0) {
    const ccAbility = usableAbilities.find(a =>
      a.effects.some(e => e.type === 'stun')
    );
    if (ccAbility) {
      // Target highest threat enemy
      const highestThreat = enemies.reduce((highest, current) =>
        current.stats.atk > highest.stats.atk ? current : highest
      );
      return { ability: ccAbility, target: highestThreat };
    }
  }
  
  return null;
}
